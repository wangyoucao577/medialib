package box

import (
	"bytes"
	"io"
	"testing"
)

func TestParseHeader(t *testing.T) {
	cases := []struct {
		data               []byte
		expectedErr        error
		expectedHeaderSize uint64
	}{

		// size(4) + type(4)
		{nil, ErrInsufficientSize, 0},
		{[]byte{}, ErrInsufficientSize, 0},
		{[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, ErrInsufficientSize, 0},
		{[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, nil, 8},

		// size(4) + type(4) + largeSize(8)
		{[]byte{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}, ErrInsufficientSize, 8},
		{[]byte{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, ErrInsufficientSize, 8},
		{[]byte{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, nil, 16},

		// size(4) + type(4) + uuid(16)
		{[]byte{0x00, 0x00, 0x00, 0x00, 'u', 'u', 'i', 'd'}, ErrInsufficientSize, 8},
		{[]byte{0x00, 0x00, 0x00, 0x00, 'u', 'u', 'i', 'd', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, ErrInsufficientSize, 8},
		{[]byte{0x00, 0x00, 0x00, 0x00, 'u', 'u', 'i', 'd', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, nil, 24},

		// size(4) + type(4) + largeSize(8) + uuid(16)
		{[]byte{0x00, 0x00, 0x00, 0x01, 'u', 'u', 'i', 'd', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, ErrInsufficientSize, 8},
		{[]byte{0x00, 0x00, 0x00, 0x01, 'u', 'u', 'i', 'd', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, ErrInsufficientSize, 16},
		{[]byte{0x00, 0x00, 0x00, 0x01, 'u', 'u', 'i', 'd', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, nil, 32},
	}

	for _, c := range cases {
		boxHeader := Header{}
		err := boxHeader.Parse(bytes.NewReader(c.data), uint64(len(c.data)))
		if err != c.expectedErr {
			t.Errorf("parse %v expect %v but got %v", c.data, c.expectedErr, err)
		}

		if boxHeader.HeaderSize() != c.expectedHeaderSize {
			t.Errorf("parse %v expect header size %v but got %v", c.data, c.expectedHeaderSize, boxHeader.HeaderSize())
		}
	}
}

func TestParseBox(t *testing.T) {

	cases := []struct {
		data               []byte
		expectedErr        error
		expectedParsedSize uint64
	}{
		// invalid header only
		{nil, ErrInsufficientSize, 0},
		{[]byte{}, ErrInsufficientSize, 0},
		{[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, ErrInsufficientSize, 7},

		// mock unknown box type
		{[]byte{0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00}, ErrUnknownBoxType, 8},
		{[]byte{0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00}, ErrUnknownBoxType, 9},
		{[]byte{0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, ErrUnknownBoxType, 9},

		// mock unknown box type + invalid size
		{[]byte{0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00}, ErrUnknownBoxType, 9},

		// mock valid box
		{[]byte{0x00, 0x00, 0x00, 0x09, 'm', 'o', 'c', 'k', 0x00}, nil, 9},
	}

	for _, c := range cases {
		parsedBytes, err := ParseBox(bytes.NewReader(c.data), &testBox{}, uint64(len(c.data)))
		if err != c.expectedErr {
			t.Errorf("parse %v expect %v but got %v", c.data, c.expectedErr, err)
		}

		if parsedBytes != c.expectedParsedSize {
			t.Errorf("parse %v expect parsed size %v but got %v", c.data, c.expectedParsedSize, parsedBytes)
		}
	}
}

type testBox struct {
	Header `json:"header"`
}

func (b *testBox) ParsePayload(r io.Reader) error {
	return nil
}

func (t *testBox) CreateSubBox(h Header) (Box, error) {
	if h.Type.String() == "mock" { // use self as mock
		return &testBox{}, nil
	}
	return nil, ErrUnknownBoxType // mock unknown
}
